# =============================================================================
# Function Specification: executeCode
# =============================================================================

function:
  id: backend_python_tools.execute_code
  name: execute_code
  module: backend_python_tools
  purpose: |
    Execute Python code or shell commands in a sandboxed environment scoped
    to a project. Provides isolated execution with resource limits, output
    capture, and security restrictions.

  signature:
    parameters:
      - name: code
        type: string
        required: true
        description: "Code or command to execute"
      - name: language
        type: string
        required: true
        description: "Execution language"
        constraints:
          - "Must be 'python' or 'shell'"
      - name: project_path
        type: string
        required: true
        description: "Project root directory for execution context"
      - name: options
        type: ExecuteOptions
        required: false
        default: {}
        description: "Execution options"
        constraints:
          - "timeout: max execution time in seconds (default 30)"
          - "capture_output: boolean (default true)"
          - "working_dir: relative path within project"
    returns:
      type: ExecuteResult
      description: "Execution result"
      schema:
        properties:
          success:
            type: boolean
          exit_code:
            type: integer
          stdout:
            type: string
          stderr:
            type: string
          duration_ms:
            type: integer
          files_modified:
            type: array
            items:
              type: string
    throws:
      - type: TimeoutError
        condition: "Execution exceeds timeout"
      - type: SecurityError
        condition: "Code attempts forbidden operation"
      - type: ExecutionError
        condition: "Code fails to execute"

  contract:
    preconditions:
      - "code is non-empty string"
      - "language is 'python' or 'shell'"
      - "project_path exists and is valid project"
      - "User has permission to execute in project"
    postconditions:
      - "Returns execution result"
      - "Output is captured if requested"
      - "Modified files are tracked"
      - "Execution stays within project directory"
    invariants:
      - "Cannot access files outside project"
      - "Cannot execute system commands (shell)"
      - "Resource limits are enforced"
    side_effects:
      - type: io_operation
        description: "May create/modify files in project"
        scope: "project_path/"
      - type: process_execution
        description: "Spawns subprocess for execution"
        scope: "Isolated process"

  algorithm:
    description: |
      1. Validate inputs
      2. Resolve working directory
      3. Create sandbox environment
      4. Set resource limits
      5. Execute code in subprocess
      6. Capture output
      7. Track file modifications
      8. Return result

    steps:
      - step: 1
        action: "Validate code, language, project_path"
        rationale: "Ensure valid inputs"
      - step: 2
        action: "Resolve working_dir relative to project_path"
        rationale: "Set execution context"
      - step: 3
        action: "Create isolated environment with restricted PATH"
        rationale: "Security isolation"
      - step: 4
        action: "Set timeout, memory, and process limits"
        rationale: "Resource protection"
      - step: 5
        action: "Execute via subprocess with captured I/O"
        rationale: "Isolated execution"
      - step: 6
        action: "Capture stdout and stderr"
        rationale: "Provide output to caller"
      - step: 7
        action: "Compare file state before/after for modifications"
        rationale: "Track changes"
      - step: 8
        action: "Return ExecuteResult"
        rationale: "Provide complete result"

    fol_specification: |
      forall code in String, lang in {python, shell}, path in Path:
        ValidProject(path) and NonEmpty(code) implies
          let result = execute_code(code, lang, path) in
          result.exit_code >= 0 and
          (result.success iff result.exit_code = 0) and
          forall f in result.files_modified:
            StartsWith(f, path)

    pseudocode: |
      def execute_code(code: str, language: str, project_path: str, options: dict = {}):
          # Step 1: Validate
          if not code.strip():
              raise ValidationError("Empty code")
          if language not in ['python', 'shell']:
              raise ValidationError(f"Unsupported language: {language}")
          if not os.path.isdir(project_path):
              raise ValidationError("Invalid project path")
          
          # Step 2: Resolve working directory
          working_dir = project_path
          if options.get('working_dir'):
              working_dir = os.path.join(project_path, options['working_dir'])
              # Security: ensure within project
              if not working_dir.startswith(os.path.realpath(project_path)):
                  raise SecurityError("Working directory outside project")
          
          # Step 3: Create sandbox environment
          env = create_sandbox_env(project_path)
          
          # Step 4: Set limits
          timeout = options.get('timeout', 30)
          
          # Track files before execution
          files_before = snapshot_files(project_path)
          
          # Step 5: Execute
          start_time = time.time()
          
          try:
              if language == 'python':
                  result = subprocess.run(
                      ['python3', '-c', code],
                      cwd=working_dir,
                      env=env,
                      capture_output=True,
                      timeout=timeout,
                      text=True
                  )
              else:  # shell
                  # Use restricted shell
                  result = subprocess.run(
                      ['bash', '-r', '-c', code],
                      cwd=working_dir,
                      env=env,
                      capture_output=True,
                      timeout=timeout,
                      text=True
                  )
          except subprocess.TimeoutExpired:
              raise TimeoutError(f"Execution timed out after {timeout}s")
          
          duration_ms = int((time.time() - start_time) * 1000)
          
          # Step 6-7: Capture output and track files
          files_after = snapshot_files(project_path)
          files_modified = diff_files(files_before, files_after)
          
          # Step 8: Return result
          return {
              'success': result.returncode == 0,
              'exit_code': result.returncode,
              'stdout': result.stdout,
              'stderr': result.stderr,
              'duration_ms': duration_ms,
              'files_modified': files_modified
          }

  complexity:
    time: "O(1) + execution time"
    space: "O(n)"
    analysis: |
      Time:
        - Setup: O(1)
        - Execution: Variable (bounded by timeout)
        - File tracking: O(f) where f = files in project
      
      Space:
        - Output capture: O(n) where n = output size
        - File snapshots: O(f)

  data_access:
    reads:
      - entity: Project
        operations: [read_path, read_files]
    writes:
      - entity: DataEntity
        operations: [create, update]
    transactions: false

  error_handling:
    validation:
      - parameter: code
        validation: "Must be non-empty"
        error_code: "EMPTY_CODE"
      - parameter: language
        validation: "Must be python or shell"
        error_code: "INVALID_LANGUAGE"
      - parameter: project_path
        validation: "Must be valid directory"
        error_code: "INVALID_PATH"
    error_cases:
      - condition: "Timeout exceeded"
        error_type: TimeoutError
        recovery: "Kill process, return partial output"
      - condition: "Path traversal attempt"
        error_type: SecurityError
        recovery: propagate
      - condition: "Execution fails"
        error_type: ExecutionError
        recovery: "Return error output"

  testing:
    unit_tests:
      - name: "executes Python code"
        scenario: "Simple print statement"
        inputs:
          code: "print('Hello')"
          language: "python"
          project_path: "/tmp/test_project"
        expected_output:
          success: true
          exit_code: 0
          stdout: "Hello\n"

      - name: "executes shell command"
        scenario: "Echo command"
        inputs:
          code: "echo 'Hello'"
          language: "shell"
          project_path: "/tmp/test_project"
        expected_output:
          success: true
          stdout: "Hello\n"

      - name: "handles timeout"
        scenario: "Infinite loop"
        inputs:
          code: "while True: pass"
          language: "python"
          project_path: "/tmp/test_project"
          options:
            timeout: 1
        expected_output:
          error: TimeoutError

      - name: "tracks file modifications"
        scenario: "Code creates file"
        inputs:
          code: "with open('test.txt', 'w') as f: f.write('test')"
          language: "python"
          project_path: "/tmp/test_project"
        expected_output:
          success: true
          files_modified: ["test.txt"]

      - name: "blocks path traversal"
        scenario: "Attempt to access parent"
        inputs:
          code: "cat ../../../etc/passwd"
          language: "shell"
          project_path: "/tmp/test_project"
        expected_output:
          error: SecurityError

    edge_cases:
      - "Very large output"
      - "Binary output"
      - "Code with syntax error"
      - "Code that forks processes"
      - "Code that tries to install packages"

    integration_tests:
      - "Execute code and verify file created"
      - "Execute code with project context"
      - "Verify resource limits enforced"

  llm_guidance:
    implementation_hints: |
      1. Use subprocess with timeout
      2. Create restricted environment variables
      3. Use chroot or containers for stronger isolation (Phase 3+)
      4. Track file modifications via timestamps or hashes
      5. Limit output size to prevent memory issues

    key_considerations:
      - "SECURITY: Never execute untrusted code without sandbox"
      - "SECURITY: Restrict PATH and environment"
      - "SECURITY: Prevent path traversal"
      - "Always enforce timeout"
      - "Capture both stdout and stderr"
      - "Track file modifications for audit"

    example_code: |
      import subprocess
      import os
      import time
      from pathlib import Path
      
      def create_sandbox_env(project_path: str) -> dict:
          """Create restricted environment for execution."""
          return {
              'PATH': '/usr/bin:/bin',
              'HOME': project_path,
              'PYTHONPATH': '',
              'PROJECT_ROOT': project_path,
              # Prevent network access hints
              'http_proxy': '',
              'https_proxy': '',
          }
      
      def snapshot_files(directory: str) -> dict:
          """Snapshot file modification times."""
          snapshot = {}
          for root, dirs, files in os.walk(directory):
              for f in files:
                  path = os.path.join(root, f)
                  rel_path = os.path.relpath(path, directory)
                  snapshot[rel_path] = os.path.getmtime(path)
          return snapshot
      
      def diff_files(before: dict, after: dict) -> list:
          """Find modified files."""
          modified = []
          for path, mtime in after.items():
              if path not in before or before[path] != mtime:
                  modified.append(path)
          return modified
      
      def execute_code(code: str, language: str, project_path: str, options: dict = None):
          options = options or {}
          
          # Validate
          if not code.strip():
              raise ValidationError("Empty code")
          if language not in ['python', 'shell']:
              raise ValidationError(f"Unsupported language: {language}")
          
          project_path = os.path.realpath(project_path)
          if not os.path.isdir(project_path):
              raise ValidationError("Invalid project path")
          
          # Resolve working directory
          working_dir = project_path
          if options.get('working_dir'):
              working_dir = os.path.realpath(
                  os.path.join(project_path, options['working_dir'])
              )
              if not working_dir.startswith(project_path):
                  raise SecurityError("Working directory outside project")
          
          # Setup
          env = create_sandbox_env(project_path)
          timeout = options.get('timeout', 30)
          files_before = snapshot_files(project_path)
          
          # Execute
          start_time = time.time()
          
          try:
              if language == 'python':
                  cmd = ['python3', '-c', code]
              else:
                  cmd = ['bash', '-r', '-c', code]
              
              result = subprocess.run(
                  cmd,
                  cwd=working_dir,
                  env=env,
                  capture_output=True,
                  timeout=timeout,
                  text=True
              )
          except subprocess.TimeoutExpired as e:
              raise TimeoutError(f"Execution timed out after {timeout}s")
          
          duration_ms = int((time.time() - start_time) * 1000)
          files_after = snapshot_files(project_path)
          
          return {
              'success': result.returncode == 0,
              'exit_code': result.returncode,
              'stdout': result.stdout[:100000],  # Limit output
              'stderr': result.stderr[:100000],
              'duration_ms': duration_ms,
              'files_modified': diff_files(files_before, files_after)
          }

    common_mistakes:
      - "Not enforcing timeout"
      - "Not restricting environment"
      - "Allowing path traversal"
      - "Not capturing stderr"
      - "Unlimited output capture"

  references:
    - "spec/apis.yaml#execute_code"
    - "spec/modules/backend_python_tools.yaml"